import { type NextRequest, NextResponse } from "next/server";

const BACKEND_BASE_URL = process.env.NEXT_PUBLIC_BASE_URL;

export async function POST(request: NextRequest) {
  try {
    const { content, options = {} } = await request.json();

    if (!content || content.trim().length === 0) {
      return NextResponse.json({ error: "Content is required" }, { status: 400 });
    }

    console.log("Processing content for backend analysis:", content.substring(0, 100) + "...");

    // Call the backend's manual analysis endpoint
    const backendResponse = await fetch(`${BACKEND_BASE_URL}/analyze-manual`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ content: content, headline: content.substring(0, 100) }), // Pass content and a generated headline
    });

    console.log("Backend response status:", backendResponse.status);

    if (!backendResponse.ok) {
      const errorData = await backendResponse.json();
      throw new Error(`Backend analysis failed: ${errorData.error || backendResponse.statusText}`);
    }

    const result = await backendResponse.json();
    console.log("Backend analysis result:", result);

    if (result.success && result.analysis) {
      const analysis = result.analysis;

      // The backend now provides the comprehensive analysis directly.
      // We can also include embeddings if they were generated by the backend
      const responseAnalysis = {
        ...analysis,
        processing_timestamp: new Date().toISOString(),
        processing_method: analysis.model_version || "gemini-2.0-flash-001 (via backend)", // Use backend's model version
        mongodb_stored: options.store_in_mongodb || false, // The backend handles storage
      };

      // Generate additional insights on the frontend if needed, based on the backend's analysis
      const insights = generateAdditionalInsights(responseAnalysis);

      return NextResponse.json({
        success: true,
        analysis: {
          ...responseAnalysis,
          additional_insights: insights,
        },
        metadata: {
          content_length: content.length,
          processing_model: responseAnalysis.processing_method,
          api_version: "3.1",
          mongodb_integration: true,
        },
      });
    } else {
      throw new Error(result.error || "Backend analysis failed - no valid response.");
    }
  } catch (error: any) {
    console.error("AI Analysis Error:", error);

    const fallbackAnalysis = {
      bias_analysis: { overall_score: 0.3, political_leaning: "neutral", bias_indicators: [], language_bias: 0.3, source_bias: 0.3, framing_bias: 0.3, selection_bias: 0.3, confirmation_bias: 0.3 },
      misinformation_analysis: { risk_score: 0.2, fact_checks: [], red_flags: [], logical_fallacies: [], evidence_quality: 0.5 },
      sentiment_analysis: { overall_sentiment: 0.0, emotional_tone: "neutral", key_phrases: [], emotional_manipulation: 0.0, subjectivity_score: 0.0 },
      credibility_assessment: { overall_score: 0.7, evidence_quality: 0.7, source_reliability: 0.7, logical_consistency: 0.7, transparency: 0.7 },
      narrative_analysis: { primary_frame: "informational", secondary_frames: [], narrative_patterns: [], actor_portrayal: {}, perspective_diversity: 0.5 },
      technical_analysis: { readability_score: 0.5, complexity_level: "moderate", word_count: content.split(/\s+/).length, key_topics: ["general"], named_entities: [] },
      recommendations: { verification_needed: [], alternative_sources: [], critical_questions: [], bias_mitigation: [] },
      confidence: 0.5,
      model_version: "fallback (frontend)",
      processing_timestamp: new Date().toISOString(),
      processing_method: "fallback (frontend)",
      mongodb_stored: false,
    };

    return NextResponse.json({
      success: true,
      analysis: fallbackAnalysis,
      metadata: {
        processing_model: "fallback (frontend)",
        note: "Fallback analysis due to system error or invalid backend response",
      },
    });
  }
}

function generateAdditionalInsights(analysis: any) {
  const insights = [];

  // Bias insights
  if (analysis.bias_analysis?.overall_score > 0.7) {
    insights.push({
      type: "bias_warning",
      severity: "high",
      message: "High bias detected. Consider seeking alternative perspectives.",
      details: analysis.bias_analysis.bias_indicators || [],
    });
  }

  // Misinformation insights
  if (analysis.misinformation_analysis?.risk_score > 0.6) {
    insights.push({
      type: "misinformation_alert",
      severity: "high",
      message: "High misinformation risk. Fact-checking recommended.",
      details: analysis.misinformation_analysis.red_flags || [],
    });
  }

  // Credibility insights
  if (analysis.credibility_assessment?.overall_score < 0.4) {
    insights.push({
      type: "credibility_concern",
      severity: "medium",
      message: "Low credibility score. Verify claims independently.",
      details: ["Low source quality", "Insufficient evidence"],
    });
  }

  return insights;
}